package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html/template"
	"image/color"
	"io/ioutil"
	"math"
	"net/http"
	"net/url"
	"os"
	"path"
	"strconv"
)

type Response struct {
	Info struct {
		Colors [5]string `json:"colors"`
	} `json:"info"`
}

type Theme struct {
	Core     StateTheme
	Focused  StateTheme
	Active   StateTheme
	Inactive StateTheme
	Urgent   StateTheme
}

type StateTheme struct {
	Border, Background, Font string
}

func NewStateTheme(c color.RGBA) StateTheme {
	title, body := GenerateTextColors(c)
	return StateTheme{
		Background: toHex(c),
		Font:       toHex(compositeColors(title, c)),
		Border:     toHex(compositeColors(body, c)),
	}
}

func main() {
	imgData, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}
	resp, err := http.PostForm("http://pictaculous.com/api/1.0/", url.Values{
		"image": {string(imgData)},
	})
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()
	var result Response

	json.NewDecoder(resp.Body).Decode(&result)

	colors := []color.RGBA{}

	for _, c := range result.Info.Colors {
		n, err := strconv.ParseUint("0x"+c+"00", 0, 32)
		if err != nil {
			fmt.Println(err)
			continue
		}
		colors = append(colors, color.RGBA{
			R: uint8(n & 0xff000000 >> 24),
			G: uint8(n & 0x00ff0000 >> 16),
			B: uint8(n & 0x0000ff00 >> 8),
			A: math.MaxUint8,
		})
	}

	title, body := GenerateTextColors(colors[0])
	title = compositeColors(title, colors[0])
	body = compositeColors(body, colors[0])

	theme := Theme{
		Focused:  NewStateTheme(colors[0]),
		Active:   NewStateTheme(colors[1]),
		Inactive: NewStateTheme(colors[0]),
		Urgent:   NewStateTheme(colors[0]),
		Core:     NewStateTheme(colors[0]),
	}

	buf := new(bytes.Buffer)
	err = template.Must(template.New("root").Parse(configTmpl)).
		Execute(buf, theme)
	if err != nil {
		fmt.Println(err)
		return
	}

	configFilePath := path.Join(os.Getenv("HOME"), "/.config/i3/config")

	configFile, err := ioutil.ReadFile(configFilePath)
	if err != nil {
		fmt.Println(err)
		return
	}

	i := bytes.Index(configFile, []byte("#AUTOGENERATED"))
	newConfigFile := append(configFile[:i], buf.Bytes()...)
	f, err := os.OpenFile(configFilePath, os.O_WRONLY|os.O_TRUNC, 0660)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	_, err = f.Write(newConfigFile)
	if err != nil {
		fmt.Println(err)
		return
	}
}

func toHex(c color.RGBA) string {
	var rgba uint32
	rgba |= (uint32(c.R) << 16)
	rgba |= (uint32(c.G) << 8)
	rgba |= (uint32(c.B) << 0)
	return fmt.Sprintf("%06x", rgba)
}

const configTmpl = `#AUTOGENERATED BELOW THIS LINE

bar {
    colors {
        # Whole color settings
        background #{{.Core.Background}}
        statusline #{{.Core.Border}}
        separator  #{{.Core.Font}}

        # Type             border  background font
        focused_workspace  #{{.Focused.Border}} #{{.Focused.Background}} #{{.Focused.Font}}
        active_workspace   #{{.Active.Border}} #{{.Active.Background}} #{{.Active.Font}}
        inactive_workspace #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}}
        urgent_workspace   #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}}
    }

    status_command i3status
}

# class                 border  backgr. text    indicator child_border
client.focused          #{{.Focused.Border}} #{{.Focused.Background}} #{{.Focused.Font}} #{{.Core.Border}} #{{.Focused.Background}}
client.focused_inactive #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}} #{{.Core.Border}} #{{.Inactive.Background}}
client.unfocused        #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}} #{{.Core.Border}} #{{.Inactive.Background}}
client.urgent           #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}} #{{.Core.Border}} #{{.Urgent.Background}}
client.placeholder      #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}} #{{.Core.Border}} #{{.Urgent.Background}}

client.background       #{{.Core.Background}}
`
