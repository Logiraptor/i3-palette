package main

import (
	"bytes"
	"fmt"
	"html/template"
	"image"
	"image/color"
	_ "image/png"
	"io/ioutil"
	"os"
	"path"
)

type Response struct {
	Info struct {
		Colors [5]string `json:"colors"`
	} `json:"info"`
}

type Theme struct {
	Core     StateTheme
	Focused  StateTheme
	Active   StateTheme
	Inactive StateTheme
	Urgent   StateTheme
}

type StateTheme struct {
	Border, Background, Font string
}

func NewStateTheme(c color.RGBA) StateTheme {
	title, body := GenerateTextColors(c)
	return StateTheme{
		Background: toHex(c),
		Font:       toHex(compositeColors(title, c)),
		Border:     toHex(compositeColors(body, c)),
	}
}

func main() {
	colors, err := paletteFromImage(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}

	title, body := GenerateTextColors(colors[0])
	title = compositeColors(title, colors[0])
	body = compositeColors(body, colors[0])

	theme := Theme{
		Focused:  NewStateTheme(colors[0]),
		Active:   NewStateTheme(colors[1]),
		Inactive: NewStateTheme(colors[2]),
		Urgent:   NewStateTheme(colors[3]),
		Core:     NewStateTheme(colors[4]),
	}

	buf := new(bytes.Buffer)
	err = template.Must(template.New("root").Parse(configTmpl)).
		Execute(buf, theme)
	if err != nil {
		fmt.Println(err)
		return
	}

	configFilePath := path.Join(os.Getenv("HOME"), "/.config/i3/config")

	configFile, err := ioutil.ReadFile(configFilePath)
	if err != nil {
		fmt.Println(err)
		return
	}

	i := bytes.Index(configFile, []byte("#AUTOGENERATED"))
	newConfigFile := append(configFile[:i], buf.Bytes()...)
	f, err := os.OpenFile(configFilePath, os.O_WRONLY|os.O_TRUNC, 0660)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()

	_, err = f.Write(newConfigFile)
	if err != nil {
		fmt.Println(err)
		return
	}
}

func toHex(c color.RGBA) string {
	var rgba uint32
	rgba |= (uint32(c.R) << 16)
	rgba |= (uint32(c.G) << 8)
	rgba |= (uint32(c.B) << 0)
	return fmt.Sprintf("%06x", rgba)
}

const configTmpl = `#AUTOGENERATED BELOW THIS LINE

bar {
    colors {
        # Whole color settings
        background #{{.Core.Background}}
        statusline #{{.Core.Border}}
        separator  #{{.Core.Font}}

        # Type             border  background font
        focused_workspace  #{{.Focused.Border}} #{{.Focused.Background}} #{{.Focused.Font}}
        active_workspace   #{{.Active.Border}} #{{.Active.Background}} #{{.Active.Font}}
        inactive_workspace #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}}
        urgent_workspace   #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}}
    }

    status_command i3status
}

# class                 border  backgr. text    indicator child_border
client.focused          #{{.Focused.Border}} #{{.Focused.Background}} #{{.Focused.Font}} #{{.Core.Border}} #{{.Focused.Background}}
client.focused_inactive #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}} #{{.Core.Border}} #{{.Inactive.Background}}
client.unfocused        #{{.Inactive.Border}} #{{.Inactive.Background}} #{{.Inactive.Font}} #{{.Core.Border}} #{{.Inactive.Background}}
client.urgent           #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}} #{{.Core.Border}} #{{.Urgent.Background}}
client.placeholder      #{{.Urgent.Border}} #{{.Urgent.Background}} #{{.Urgent.Font}} #{{.Core.Border}} #{{.Urgent.Background}}

client.background       #{{.Core.Background}}
`

func paletteFromImage(fileName string) ([]color.RGBA, error) {
	f, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	img, _, err := image.Decode(f)
	if err != nil {
		return nil, err
	}

	c := ColorCut{}
	palette := c.Quantize(make(color.Palette, 0, 5), img)

	colors := []color.RGBA{}

	for _, c := range palette {
		fmt.Println(toHex(color.RGBAModel.Convert(c).(color.RGBA)))
		colors = append(colors, color.RGBAModel.Convert(c).(color.RGBA))
	}

	return colors, nil
}
